## 関数メモ
### リスト操作
- `concat`: リスト内リストの各要素を-1次元のリストに連結する
- `concatMap`: `concat`の各要素に関数を適用できるもの。第1引数に関数を、第2引数に対象のリストを指定する
- `replicate`: 指定した数だけその値を持つリストを生成する
- `scanl`: 累積和を計算する関数。第1引数に関数、第2引数に初期値、第3引数にリストを指定する

```haskell
concat ["A", "B", "C"]
-- > "ABC"
concatMap (++[1]) [[2],[3],[4]]
-- > [2,1,3,1,4,1]
```

## データ構造について
### インデックスアクセス時はリストを配列に変換したほうが良い
ref: [リスト \- ウォークスルー Haskell](http://walk.northcol.org/haskell/lists/#_%E3%83%AA%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF)

Haskellではリストを使うことによって代数的データ型で複数データを表すことが出来るので、リスト型を好んで使用する。
しかし、累積和の計算など、リストの要素にインデックスアクセスを行う場合は、リストの要素数が多くなると計算量がO(n)となり、パフォーマンスが悪化する。
そのため、配列に変換することが求められる。配列のインデックスアクセスはO(1)であるため、パフォーマンスが向上する。

```haskell
import Data.Array
-- リストから配列を作成する例
-- listArray (開始インデックス, 終了インデックス) [要素リスト]
let arr = listArray (0, 2) [10, 20, 30]
-- arr ! 1 で20を取得できる
```

#### 参考
- [Haskellの勉強 \(5\) \- リスト \(2\) \- てきとうなメモ](https://boscono.hatenablog.com/entry/20060618/p1)
- [リストを操作する関数一覧\(Haskell\)](https://zenn.dev/masahiro_toba/articles/b5fa0ba4766e16#%EF%BC%93%E3%80%81%E7%84%A1%E9%99%90%E7%B3%BB%E3%81%AB%E3%81%BE%E3%81%A4%E3%82%8F%E3%82%8B%E9%96%A2%E6%95%B0(3%E3%81%A4))
- [GHC\.List を読んで Haskell のリスト操作をまとめた \#Haskell \- Qiita](https://qiita.com/HelloRusk/items/8cee82377587058ff0c3)

## タプル
ref: https://zenn.dev/link/comments/9abf9c51a98054
- 空のタプル、通称Unionは`()`で表される
  - これは関数が何も値を返さないときに使用できる。多言語の`void`のように使える
